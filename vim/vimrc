"  encoding setting "{{{
set encoding=utf-8      " internal encoding
scriptencoding utf-8    " encoding of script
set fileencodings=iso-2022-jp,sjis,ucs-bom,utf-8,euc-jp    " list of encoding to try on file reading
"}}}

"  serching setting "{{{
set backspace=indent,eol,start    " use backspace as backspace
set incsearch                     " incremental search
set ignorecase                    " ignore case on search
"}}}

" display of location "{{{
set ruler           " use ruler
set number          " display line number
set laststatus=2    " display status line always
"}}}

" folding "{{{
set foldlevel=0     " close all fold
set foldcolumn=4    " width of foldcolumn
"}}}

set wildmenu    " command line completion
set clipboard+=unnamed    " use system clipboard
set nobackup    " don't backup
set modeline    " use modeline
set undofile    " use undofile

syntax enable

let s:is_windows = has('win32') || has('win64')

augroup myvimrc
    autocmd!
    " Highlight trailing space
    autocmd VimEnter,WinEnter,ColorScheme * highlight TrailingSpaces term=underline guibg=Red ctermbg=Red
    autocmd VimEnter,WinEnter * match TrailingSpaces /\s\+$/
    " Don't conceal double quote of json
    autocmd Filetype json setlocal conceallevel=0
    " Don't wrap in text file
    autocmd FileType text setlocal textwidth=0
    " Use HybridText for undefined filetype
    autocmd BufEnter * if &filetype == "" | setlocal ft=hybrid | endif
augroup END

" text base tabpage: "{{{
set showtabline=2
set guioptions-=e
function! s:tabpage_label(n)
    " tabpage has title
    let title = gettabvar(a:n, 'title')
    if title !=# ''
        return title
    endif
    " highlight Selected tabpage
    let bufnrs = tabpagebuflist(a:n)
    let hi = a:n is tabpagenr() ? '%#TabLineSel#' : ' %#TabLine#'
    " number of buffers
    let no = len(bufnrs)
    if no is 1
	let no = ''
    endif
    " modified buffer
    let mod = len(filter(copy(bufnrs), 'getbufvar(v:val,  "&modified")')) ? '+' : ''
    let sp = (no . mod) ==# '' ? '' : ' '
    " filename of current buffer
    let curbufnr = bufnrs[tabpagewinnr(a:n) - 1]
    let fname = pathshorten(bufname(curbufnr))
    " return label
    let label = no . mod . sp . fname
    return '%' . a:n . 'T' . hi . label . '%T%#TabLineFill#'
endfunction
function! MakeTabLine()
    let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
    let sep = ' | '
    let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
    let info = ''
    let info .= fnamemodify(getcwd(), ':~') . ' '
    return tabpages . '%=' . info
endfunction
set tabline=%!MakeTabLine()
"}}}

" for windows "{{{
if has('vim_starting')
    if s:is_windows
        set shellpipe=
        set directory=$TEMP/
    endif
endif
"}}}

" Shougo/dein.vim: "{{{
filetype off
let g:neobundle_default_git_protocol='git'
if has('vim_starting')
    if s:is_windows
        let s:path_to_dein = '$HOME/vimfiles/dein/repos/github.com/Shougo/dein.vim'
    else
        let s:path_to_dein = '~/.vim/dein/repos/github.com/Shougo/dein.vim'
    endif
    if !isdirectory(expand(s:path_to_dein))
        echo 'install dein.vim ...'
        call system('git clone git://github.com/Shougo/dein.vim ' . expand(s:path_to_dein))
    endif
    let &runtimepath = s:path_to_dein . ',' . &runtimepath
endif
if s:is_windows
    let g:vimproc#download_windows_dll = 1
    call dein#begin(expand('$HOME/vimfiles/dein'))
else
    call dein#begin(expand('~/.vim/dein'))
endif
call dein#add('Shougo/dein.vim')
"}}}

" Shougo/vimproc.vim "{{{
if s:is_windows
    call dein#add('Shougo/vimproc.vim')
else
    call dein#add('Shougo/vimproc.vim', {'build': 'make'})
endif
"}}}

" Shogo/unite.vim and sources "{{{
call dein#add('Shougo/unite.vim')
call dein#add('Shougo/unite-help')
call dein#add('Shougo/unite-outline')
call dein#add('tsukkee/unite-tag')
"}}}

" colorschemes "{{{
call dein#add('altercation/vim-colors-solarized')
call dein#add('thinca/vim-guicolorscheme')
"}}}

" for Vim itself "{{{
call dein#add('thinca/vim-scouter')
call dein#add('mattn/benchvimrc-vim')
"}}}

" git "{{{
call dein#add('tpope/vim-fugitive')
call dein#add('rhysd/committia.vim')
"}}}

call dein#add('Shougo/neocomplete.vim')
call dein#add('Shougo/neosnippet')
call dein#add('Shougo/neosnippet-snippets')

call dein#add('Konfekt/FastFold')

call dein#add('vim-jp/vital.vim')
call dein#add('vim-jp/vimdoc-ja')
call dein#add('vim-scripts/sudo.vim')
if s:is_windows
    call dein#add('itchyny/lightline.vim')
endif
call dein#add('mhinz/vim-startify')
call dein#add('deton/imactivatemap.vim')
call dein#add('justinmk/vim-dirvish')
call dein#add('morinatsu/auto-ctags.vim')
call dein#add('PProvost/vim-ps1')
call dein#add('chrisbra/Recover.vim')
call dein#add('thinca/vim-zenspace')
call dein#add('thinca/vim-quickrun')
call dein#add('tyru/open-browser.vim')
call dein#add('HybridText')
call dein#add('osyo-manga/vim-reanimate')
call dein#add('easymotion/vim-easymotion')
call dein#add('osyo-manga/vim-over')
call dein#add('airblade/vim-rooter')
call dein#add('tpope/vim-abolish')
call dein#add('nelstrom/vim-qargs')
call dein#add('morinatsu/vim-howdoi')
call dein#add('thinca/vim-fontzoom')
call dein#add('deton/jasegment.vim')
call dein#add('osyo-manga/shabadou.vim')
call dein#add('osyo-manga/vim-watchdogs')
call dein#add('sjl/gundo.vim')
call dein#add('haya14busa/incsearch.vim')
call dein#add('kana/vim-vspec')
call dein#end()

filetype plugin on
filetype indent on

" Ok, a vim for men, get off the cursor keys {{{
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>
" }}}

" NeoComplete : "{{{
let g:acp_enableAtStartup = 0           " Disable AutoComplPop.
let g:neocomplete#enable_at_startup = 1 " Use neocomplete.
let g:neocomplete#enable_smart_case = 1 " Use smartcase.
let g:neocomplete#sources#syntax#min_keyword_length = 3 " Set minimum syntax keyword length.

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g> neocomplete#undo_completion()
inoremap <expr><C-l> neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
    return neocomplete#smart_close_popup() . "\<CR>"
endfunction

" <TAB>: completion.
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS>  neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y> neocomplete#close_popup()
inoremap <expr><C-e> neocomplete#cancel_popup()

" Enable omni completion.
augroup omni
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    autocmd FileType *
    \   if &l:omnifunc == ''
    \ |     setlocal omnifunc=syntaxcomplete#Complete
    \ | endif
augroup END

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"}}}

" NeoSnippet : "{{{
" Plugin key-mappings
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker
if has('conceal')
    set conceallevel=2 concealcursor=i
endif
"}}}

" for solarized "{{{
if has('gui_running')
    set background=light
    colorscheme solarized
else
    colorscheme default
endif
"}}}

" disable IME, when exit insert mode
inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>

" edit vimrc
nnoremap <F5> :<C-u>tabedit $MYVIMRC<CR>
nnoremap <F6> :<C-u>source $MYVIMRC<CR>
                 \ :source $MYGVIMRC<CR>

" source credential file "{{{
if s:is_windows
    let s:credential = expand('$HOME\vimfiles\vimrc_cred')
else
    let s:credential = expand('~/.vim/vimrc_cred')
endif
if filereadable(s:credential)
    execute 'source ' . s:credential
endif
"}}}

" Powerline and lightline "{{{
if !s:is_windows
    let s:powerline3path = '/usr/local/lib/python3.5/dist-packages/powerline/bindings/vim'
    let s:powerlinepath = '/usr/local/lib/python2.7/dist-packages/powerline/bindings/vim'
    if has('python3') && isdirectory(s:powerline3path)
        python3 from powerline.vim import setup as powerline_setup
        python3 powerline_setup()
        python3 del powerline_setup
        set runtimepath+=expand(s:powerline3path)
        set laststatus=2 " Always display the statusline in all windows
        set showtabline=2 " Always display the tabline, even if there is only one tab
        set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
    elseif has('python') && isdirectory(s:powerlinepath)
        python from powerline.vim import setup as powerline_setup
        python powerline_setup()
        python del powerline_setup
        set runtimepath+=expand(s:powerlinepath)
        set laststatus=2 " Always display the statusline in all windows
        set showtabline=2 " Always display the tabline, even if there is only one tab
        set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
    endif
else
    let g:lightline = {
        \ 'enable': { 'tabline': 0 },
	    \ }
endif
"}}}

" auto-ctags.vim "{{{
let g:auto_ctags = 1
let g:auto_ctags_tags_name = 'tags'
let g:auto_ctags_directory_list = ['.git']
let g:auto_ctags_tags_args = '--tag-relative --recurse --sort=yes'
if !s:is_windows
    set tags+=.git/tags;
else
    set tags+=.git\tags;
endif
"}}}

" MarkDown preview with quickrun "{{{
let g:quickrun_config = {}
let g:quickrun_config.mkd = {
            \ 'outputter' : 'browser',
            \   'command': 'pandoc',
            \   'exec': '%c --from=markdown --to=html %o %s %a',
            \ }
"}}}

" keymap for Unite-vim "{{{
nnoremap <Space> <nop>
nnoremap <Space>u :<C-u>Unite<Space>
" }}}

" startify.vim "{{{
let g:startify_skiplist = [
            \ 'COMMIT_EDITMSG',
            \ 'dein/.*/doc',
            \ escape('dein\.*\doc','\'),
            \ ]
"}}}

" Use <C-l> to clear the highlighting of :set hlsearch.
if maparg('<C-l>', 'n') ==# ''
  nnoremap <C-l> :<C-u>nohlsearch<CR>
endif

" move tabpages
nnoremap <silent> ]t :<C-u>tabnext<CR>
nnoremap <silent> [t :<C-u>tabprevious<CR>

" move quickfix
nnoremap <silent> ]c :<C-u>cnext<CR>
nnoremap <silent> [c :<C-u>cprevious<CR>

" Help in new tabs: (original) unegunn/dotfiles "{{{
function! s:helptab()
  if &buftype ==? 'help'
    execute "normal! \<C-w>T"
    nnoremap <buffer> q :q<CR>
  endif
endfunction

augroup vimrc_help
  autocmd!
  autocmd BufEnter *.txt call s:helptab()
  autocmd BufEnter *.jax call s:helptab()
augroup END
"}}}

set undodir=$HOME/.local/undodir

" jasegment
let g:jasegment#highlight = 1

" VimScript checker (vint & watchdogs) "{{{
" TODO: why can't I see running mark?
let g:quickrun_config = {
\   '_' : {
\       'outputter/buffer/running_mark' : '---->---->---->---->',
\   },
\   'hybrid/watchdogs_checker': {
\       'type': executable('textlint') ? 'watchdogs_checker/textlint' : '',
\   },
\   'text/watchdogs_checker': {
\       'type': executable('textlint') ? 'watchdogs_checker/textlint' : '',
\   },
\   'vim/watchdogs_checker': {
\       'type': executable('vint') ? 'watchdogs_checker/vint' : '',
\   },
\   'watchdogs_checker/vint' : {
\       'command'   : 'vint',
\       'exec'      : '%c %o %s:p ',
\   },
\   'watchdogs_checker/_' : {
\       'hook/copen/enable_exist_data' : 1,
\   },
\ }
augroup vint
    autocmd!
    autocmd BufWritePost .vimrc,.gvimrc,*.vim WatchdogsRunSilent
augroup END
" open quickfix window if exists error
call watchdogs#setup(g:quickrun_config)
"}}}

" gundo.vim
nnoremap <F7> :GundoToggle<CR>
if has('python3')
    let g:gundo_prefer_python3 = 1
endif

" vim-howdoi
map <Space>h <Plug>Howdoi

" vim-reanimate
let g:reanimate_save_dir = $HOME . '/.local/reanimate/save_dir'

" incsearch.vim
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

" vim: foldmethod=marker tabstop=4 shiftwidth=4 expandtab
