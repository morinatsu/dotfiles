" use backspace as backspace
set backspace=indent,eol,start

" incremental search
set incsearch

" ignore case on search
set ignorecase

" use ruler
set ruler

" command line completion
set wildmenu

" close all fold
set foldlevel=0

" use system clipboard
set clipboard+=unnamed

" display line number
set number

" display status line always
set laststatus=2

" internal encoding
set encoding=utf-8

" list of encoding to try on file reading
set fileencodings=iso-2022-jp,sjis,utf-8,euc-jp

" don't backup
set nobackup

" width of foldcolumn
set foldcolumn=4

syntax on

augroup myvimrc
    autocmd!
    " Highlight trailing space
    autocmd VimEnter,WinEnter,ColorScheme * highlight TrailingSpaces term=underline guibg=Red ctermbg=Red
    autocmd VimEnter,WinEnter * match TrailingSpaces /\s\+$/
    " Don't conceal double quote of json
    autocmd Filetype json setlocal conceallevel=0
    " Don't wrap in text file
    autocmd FileType text setlocal textwidth=0
augroup END

" text base tabpage: "{{{
set showtabline=2
set guioptions-=e
function! s:tabpage_label(n)
    " tabpage has title
    let title = gettabvar(a:n, 'title')
    if title !=# ''
        return title
    endif
    " highlight Selected tabpage
    let bufnrs = tabpagebuflist(a:n)
    let hi = a:n is tabpagenr() ? '%#TabLineSel#' : ' %#TabLine#'
    " number of buffers
    let no = len(bufnrs)
    if no is 1
	let no = ''
    endif
    " modified buffer
    let mod = len(filter(copy(bufnrs), 'getbufvar(v:val,  "&modified")')) ? '+' : ''
    let sp = (no . mod) ==# '' ? '' : ' '
    " filename of current buffer
    let curbufnr = bufnrs[tabpagewinnr(a:n) - 1]
    let fname = pathshorten(bufname(curbufnr))
    " return label
    let label = no . mod . sp . fname
    return '%' . a:n . 'T' . hi . label . '%T%#TabLineFill#'
endfunction
function! MakeTabLine()
    let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
    let sep = ' | '
    let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
    let info = ''
    let info .= fnamemodify(getcwd(), ":~") . ' '
    return tabpages . '%=' . info
endfunction
set tabline=%!MakeTabLine()
"}}}

" for dein.vim: "{{{
if &compatible
  set nocompatible
endif
filetype off
let g:neobundle_default_git_protocol='git'

if has('vim_starting')
    if has("win32") || has("win64")
        set shellpipe=
        set runtimepath+=$HOME/vimfiles/dein/repos/github.com/Shougo/dein.vim
        set undodir=$TEMP/
        set directory=$TEMP/
    else
        set runtimepath+=~/.vim/dein/repos/github.com/Shougo/dein.vim
    endif
endif
"}}}

if has("win32") || has("win64")
    call dein#begin(expand('$HOME/vimfiles/dein'))
else
    call dein#begin(expand('~/.vim/dein'))
endif
call dein#add('Shougo/dein.vim')
if has("win32") || has("win64")
    call dein#add('Shougo/vimproc.vim', {'build': 'tools\\update-dll-mingw'})
else
    call dein#add('Shougo/vimproc.vim', {'build': 'make'})
endif
call dein#add('Shougo/neocomplete.vim')
call dein#add('Shougo/neosnippet')
call dein#add('Shougo/neosnippet-snippets')
call dein#add('thinca/vim-scouter')
call dein#add('altercation/vim-colors-solarized')
call dein#add('vim-jp/vital.vim')
call dein#add('Shougo/unite.vim')
call dein#add('vim-jp/vimdoc-ja')
call dein#add('vim-scripts/sudo.vim')
if has("win32") || has("win64")
    call dein#add('itchyny/lightline.vim')
else
    call dein#add('powerline/powerline', {'rtp': 'powerline/bindings/vim/'})
endif
call dein#add('thinca/vim-guicolorscheme')
call dein#add('tsukkee/unite-help')
call dein#add('h1mesuke/unite-outline')
call dein#add('tpope/vim-fugitive')
call dein#add('mhinz/vim-startify')
call dein#add('deton/imactivatemap.vim')
call dein#add('justinmk/vim-dirvish')
call dein#add('soramugi/auto-ctags.vim')
call dein#add('tsukkee/unite-tag')
call dein#add('PProvost/vim-ps1')
call dein#add('chrisbra/Recover.vim')
call dein#add('thinca/vim-zenspace')
call dein#end()

filetype plugin on
filetype indent on

" NeoComplete : "{{{
"Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g> neocomplete#undo_completion()
inoremap <expr><C-l> neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
    return neocomplete#smart_close_popup() . "\<CR>"
    " For no inserting <CR> key.
    "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction

" <TAB>: completion.
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS>  neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y> neocomplete#close_popup()
inoremap <expr><C-e> neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"}}}

" NeoSnippet : "{{{
" Plugin key-mappings
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker
if has('conceal')
    set conceallevel=2 concealcursor=i
endif
"}}}

" for solarized
if has('gui_running')
    set background=light
    colorscheme solarized
else
    colorscheme default
endif

" disable IME, when exit insert mode
inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>

" edit vimrc
nnoremap <F5> :<C-u>tabedit $MYVIMRC<CR>
nnoremap <F6> :<C-u>source $MYVIMRC<CR>
                 \ :source $MYGVIMRC<CR>

" source credential file
if has("win32") || has("win64")
    source $HOME\vimfiles\vimrc_cred
else
    source ~/.vim/vimrc_cred
endif

" Powerline "{{{
if !has("win32") && !has("win64")
    if has("python3")
        python3 from powerline.vim import setup as powerline_setup
        python3 powerline_setup()
        python3 del powerline_setup
        set laststatus=2 " Always display the statusline in all windows
        set showtabline=2 " Always display the tabline, even if there is only one tab
        set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
    endif
    if has("python")
        python from powerline.vim import setup as powerline_setup
        python powerline_setup()
        python del powerline_setup
        set laststatus=2 " Always display the statusline in all windows
        set showtabline=2 " Always display the tabline, even if there is only one tab
        set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
    endif
endif
"}}}

" auto-ctags.vim "{{{
let g:auto_ctags = 1
let g:auto_ctags_tags_name = '.tags'
set tags=.tags;
let g:auto_ctags_directory_list = ['.git']
"}}}

" vim: foldmethod=marker
